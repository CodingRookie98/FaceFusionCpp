// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_FACE_DOMAIN_FACE_SERIALIZATION_H_
#define FLATBUFFERS_GENERATED_FACE_DOMAIN_FACE_SERIALIZATION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 && FLATBUFFERS_VERSION_MINOR == 1
                  && FLATBUFFERS_VERSION_REVISION == 21,
              "Non-compatible flatbuffers version included");

namespace domain { namespace face { namespace serialization {

struct Rect;

struct FaceBuffer;
struct FaceBufferBuilder;

struct FaceListChannel;
struct FaceListChannelBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
private:
    float x_;
    float y_;
    float width_;
    float height_;

public:
    struct Traits;
    Rect() : x_(0), y_(0), width_(0), height_(0) {}
    Rect(float _x, float _y, float _width, float _height) :
        x_(::flatbuffers::EndianScalar(_x)), y_(::flatbuffers::EndianScalar(_y)),
        width_(::flatbuffers::EndianScalar(_width)), height_(::flatbuffers::EndianScalar(_height)) {
    }
    float x() const {
        return ::flatbuffers::EndianScalar(x_);
    }
    float y() const {
        return ::flatbuffers::EndianScalar(y_);
    }
    float width() const {
        return ::flatbuffers::EndianScalar(width_);
    }
    float height() const {
        return ::flatbuffers::EndianScalar(height_);
    }
};
FLATBUFFERS_STRUCT_END(Rect, 16);

struct Rect::Traits {
    using type = Rect;
};

struct FaceBuffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef FaceBufferBuilder Builder;
    struct Traits;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_BOX = 4,
        VT_LANDMARKS = 6,
        VT_EMBEDDING = 8,
        VT_NORMED_EMBEDDING = 10,
        VT_DETECTOR_SCORE = 12,
        VT_LANDMARKER_SCORE = 14,
        VT_GENDER = 16,
        VT_AGE_MIN = 18,
        VT_AGE_MAX = 20,
        VT_RACE = 22
    };
    const domain::face::serialization::Rect* box() const {
        return GetStruct<const domain::face::serialization::Rect*>(VT_BOX);
    }
    const ::flatbuffers::Vector<float>* landmarks() const {
        return GetPointer<const ::flatbuffers::Vector<float>*>(VT_LANDMARKS);
    }
    const ::flatbuffers::Vector<float>* embedding() const {
        return GetPointer<const ::flatbuffers::Vector<float>*>(VT_EMBEDDING);
    }
    const ::flatbuffers::Vector<float>* normed_embedding() const {
        return GetPointer<const ::flatbuffers::Vector<float>*>(VT_NORMED_EMBEDDING);
    }
    float detector_score() const { return GetField<float>(VT_DETECTOR_SCORE, 0.0f); }
    float landmarker_score() const { return GetField<float>(VT_LANDMARKER_SCORE, 0.0f); }
    int8_t gender() const { return GetField<int8_t>(VT_GENDER, 0); }
    int32_t age_min() const { return GetField<int32_t>(VT_AGE_MIN, 0); }
    int32_t age_max() const { return GetField<int32_t>(VT_AGE_MAX, 0); }
    int8_t race() const { return GetField<int8_t>(VT_RACE, 0); }
    bool Verify(::flatbuffers::Verifier& verifier) const {
        return VerifyTableStart(verifier)
            && VerifyField<domain::face::serialization::Rect>(verifier, VT_BOX, 4)
            && VerifyOffset(verifier, VT_LANDMARKS) && verifier.VerifyVector(landmarks())
            && VerifyOffset(verifier, VT_EMBEDDING) && verifier.VerifyVector(embedding())
            && VerifyOffset(verifier, VT_NORMED_EMBEDDING)
            && verifier.VerifyVector(normed_embedding())
            && VerifyField<float>(verifier, VT_DETECTOR_SCORE, 4)
            && VerifyField<float>(verifier, VT_LANDMARKER_SCORE, 4)
            && VerifyField<int8_t>(verifier, VT_GENDER, 1)
            && VerifyField<int32_t>(verifier, VT_AGE_MIN, 4)
            && VerifyField<int32_t>(verifier, VT_AGE_MAX, 4)
            && VerifyField<int8_t>(verifier, VT_RACE, 1) && verifier.EndTable();
    }
};

struct FaceBufferBuilder {
    typedef FaceBuffer Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_box(const domain::face::serialization::Rect* box) {
        fbb_.AddStruct(FaceBuffer::VT_BOX, box);
    }
    void add_landmarks(::flatbuffers::Offset<::flatbuffers::Vector<float>> landmarks) {
        fbb_.AddOffset(FaceBuffer::VT_LANDMARKS, landmarks);
    }
    void add_embedding(::flatbuffers::Offset<::flatbuffers::Vector<float>> embedding) {
        fbb_.AddOffset(FaceBuffer::VT_EMBEDDING, embedding);
    }
    void add_normed_embedding(
        ::flatbuffers::Offset<::flatbuffers::Vector<float>> normed_embedding) {
        fbb_.AddOffset(FaceBuffer::VT_NORMED_EMBEDDING, normed_embedding);
    }
    void add_detector_score(float detector_score) {
        fbb_.AddElement<float>(FaceBuffer::VT_DETECTOR_SCORE, detector_score, 0.0f);
    }
    void add_landmarker_score(float landmarker_score) {
        fbb_.AddElement<float>(FaceBuffer::VT_LANDMARKER_SCORE, landmarker_score, 0.0f);
    }
    void add_gender(int8_t gender) { fbb_.AddElement<int8_t>(FaceBuffer::VT_GENDER, gender, 0); }
    void add_age_min(int32_t age_min) {
        fbb_.AddElement<int32_t>(FaceBuffer::VT_AGE_MIN, age_min, 0);
    }
    void add_age_max(int32_t age_max) {
        fbb_.AddElement<int32_t>(FaceBuffer::VT_AGE_MAX, age_max, 0);
    }
    void add_race(int8_t race) { fbb_.AddElement<int8_t>(FaceBuffer::VT_RACE, race, 0); }
    explicit FaceBufferBuilder(::flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<FaceBuffer> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FaceBuffer>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<FaceBuffer> CreateFaceBuffer(
    ::flatbuffers::FlatBufferBuilder& _fbb, const domain::face::serialization::Rect* box = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> landmarks = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> embedding = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> normed_embedding = 0,
    float detector_score = 0.0f, float landmarker_score = 0.0f, int8_t gender = 0,
    int32_t age_min = 0, int32_t age_max = 0, int8_t race = 0) {
    FaceBufferBuilder builder_(_fbb);
    builder_.add_age_max(age_max);
    builder_.add_age_min(age_min);
    builder_.add_landmarker_score(landmarker_score);
    builder_.add_detector_score(detector_score);
    builder_.add_normed_embedding(normed_embedding);
    builder_.add_embedding(embedding);
    builder_.add_landmarks(landmarks);
    builder_.add_box(box);
    builder_.add_race(race);
    builder_.add_gender(gender);
    return builder_.Finish();
}

struct FaceBuffer::Traits {
    using type = FaceBuffer;
    static auto constexpr Create = CreateFaceBuffer;
};

inline ::flatbuffers::Offset<FaceBuffer> CreateFaceBufferDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb, const domain::face::serialization::Rect* box = nullptr,
    const std::vector<float>* landmarks = nullptr, const std::vector<float>* embedding = nullptr,
    const std::vector<float>* normed_embedding = nullptr, float detector_score = 0.0f,
    float landmarker_score = 0.0f, int8_t gender = 0, int32_t age_min = 0, int32_t age_max = 0,
    int8_t race = 0) {
    auto landmarks__ = landmarks ? _fbb.CreateVector<float>(*landmarks) : 0;
    auto embedding__ = embedding ? _fbb.CreateVector<float>(*embedding) : 0;
    auto normed_embedding__ = normed_embedding ? _fbb.CreateVector<float>(*normed_embedding) : 0;
    return domain::face::serialization::CreateFaceBuffer(
        _fbb, box, landmarks__, embedding__, normed_embedding__, detector_score, landmarker_score,
        gender, age_min, age_max, race);
}

struct FaceListChannel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef FaceListChannelBuilder Builder;
    struct Traits;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE { VT_FACES = 4 };
    const ::flatbuffers::Vector<::flatbuffers::Offset<domain::face::serialization::FaceBuffer>>*
    faces() const {
        return GetPointer<const ::flatbuffers::Vector<
            ::flatbuffers::Offset<domain::face::serialization::FaceBuffer>>*>(VT_FACES);
    }
    bool Verify(::flatbuffers::Verifier& verifier) const {
        return VerifyTableStart(verifier) && VerifyOffset(verifier, VT_FACES)
            && verifier.VerifyVector(faces()) && verifier.VerifyVectorOfTables(faces())
            && verifier.EndTable();
    }
};

struct FaceListChannelBuilder {
    typedef FaceListChannel Table;
    ::flatbuffers::FlatBufferBuilder& fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_faces(
        ::flatbuffers::Offset<
            ::flatbuffers::Vector<::flatbuffers::Offset<domain::face::serialization::FaceBuffer>>>
            faces) {
        fbb_.AddOffset(FaceListChannel::VT_FACES, faces);
    }
    explicit FaceListChannelBuilder(::flatbuffers::FlatBufferBuilder& _fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<FaceListChannel> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<FaceListChannel>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<FaceListChannel> CreateFaceListChannel(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    ::flatbuffers::Offset<
        ::flatbuffers::Vector<::flatbuffers::Offset<domain::face::serialization::FaceBuffer>>>
        faces = 0) {
    FaceListChannelBuilder builder_(_fbb);
    builder_.add_faces(faces);
    return builder_.Finish();
}

struct FaceListChannel::Traits {
    using type = FaceListChannel;
    static auto constexpr Create = CreateFaceListChannel;
};

inline ::flatbuffers::Offset<FaceListChannel> CreateFaceListChannelDirect(
    ::flatbuffers::FlatBufferBuilder& _fbb,
    const std::vector<::flatbuffers::Offset<domain::face::serialization::FaceBuffer>>* faces =
        nullptr) {
    auto faces__ =
        faces ? _fbb.CreateVector<::flatbuffers::Offset<domain::face::serialization::FaceBuffer>>(
                    *faces) :
                0;
    return domain::face::serialization::CreateFaceListChannel(_fbb, faces__);
}

inline const domain::face::serialization::FaceListChannel* GetFaceListChannel(const void* buf) {
    return ::flatbuffers::GetRoot<domain::face::serialization::FaceListChannel>(buf);
}

inline const domain::face::serialization::FaceListChannel* GetSizePrefixedFaceListChannel(
    const void* buf) {
    return ::flatbuffers::GetSizePrefixedRoot<domain::face::serialization::FaceListChannel>(buf);
}

inline bool VerifyFaceListChannelBuffer(::flatbuffers::Verifier& verifier) {
    return verifier.VerifyBuffer<domain::face::serialization::FaceListChannel>(nullptr);
}

inline bool VerifySizePrefixedFaceListChannelBuffer(::flatbuffers::Verifier& verifier) {
    return verifier.VerifySizePrefixedBuffer<domain::face::serialization::FaceListChannel>(nullptr);
}

inline void FinishFaceListChannelBuffer(
    ::flatbuffers::FlatBufferBuilder& fbb,
    ::flatbuffers::Offset<domain::face::serialization::FaceListChannel> root) {
    fbb.Finish(root);
}

inline void FinishSizePrefixedFaceListChannelBuffer(
    ::flatbuffers::FlatBufferBuilder& fbb,
    ::flatbuffers::Offset<domain::face::serialization::FaceListChannel> root) {
    fbb.FinishSizePrefixed(root);
}

}}} // namespace domain::face::serialization

#endif // FLATBUFFERS_GENERATED_FACE_DOMAIN_FACE_SERIALIZATION_H_
